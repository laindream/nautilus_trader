# 架构

欢迎来到NautilusTrader的架构概述。

本指南深入探讨支撑平台的基础原理、结构和设计。无论您是开发人员、系统架构师，还是对NautilusTrader内部工作原理感兴趣，本节涵盖：

- 驱动决策并塑造系统演进的设计哲学。
- 提供整个系统框架鸟瞰图的总体系统架构。
- 框架如何组织以促进模块化和可维护性。
- 确保可读性和可扩展性的代码结构。
- 组件组织和交互的细分，以理解不同部分如何通信和协作。
- 最后，对性能、可靠性和健壮性至关重要的实现技术。

:::note
在整个文档中，术语*"Nautilus系统边界"*指的是单个Nautilus节点运行时内的操作（也称为"交易者实例"）。
:::

## 设计哲学

NautilusTrader采用的主要架构技术和设计模式包括：

- [领域驱动设计(DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)
- [事件驱动架构](https://en.wikipedia.org/wiki/Event-driven_programming)
- [消息传递模式](https://en.wikipedia.org/wiki/Messaging_pattern)（发布/订阅、请求/响应、点对点）
- [端口和适配器](https://en.wikipedia.org/wiki/Hexagonal_architecture_(software))
- [仅崩溃设计](https://en.wikipedia.org/wiki/Crash-only_software)

这些技术已被用来帮助实现某些架构质量属性。

### 质量属性

架构决策通常是竞争优先级之间的权衡。下面是在做出设计和架构决策时考虑的一些最重要的质量属性列表，大致按"权重"顺序排列。

- 可靠性
- 性能
- 模块化
- 可测试性
- 可维护性
- 可部署性

## 系统架构

NautilusTrader代码库实际上既是组成交易系统的框架，也是一组可以在各种[环境上下文](#environment-contexts)中运行的默认系统实现。

![Architecture](https://github.com/nautechsystems/nautilus_trader/blob/develop/assets/architecture-overview.png?raw=true "architecture")

### 核心组件

平台围绕几个关键组件构建，这些组件协同工作以提供全面的交易系统：

#### NautilusKernel

负责以下功能的中央编排组件：

- 初始化和管理所有系统组件。
- 配置消息传递基础设施。
- 维护环境特定的行为。
- 协调共享资源和生命周期管理。
- 为系统操作提供统一入口点。

#### MessageBus

组件间通信的骨干，实现：

- **发布/订阅模式**：用于向多个消费者广播事件和数据。
- **请求/响应通信**：用于需要确认的操作。
- **命令/事件消息传递**：用于触发操作和通知状态更改。
- **可选状态持久化**：使用Redis进行持久性和重启功能。

#### Cache

高性能内存存储系统，可以：

- 存储工具、账户、订单、头寸等。
- 为交易组件提供高性能的获取功能。
- 在整个系统中维护一致状态。
- 支持具有优化访问模式的读写操作。

#### DataEngine

在整个系统中处理和路由市场数据：

- 处理多种数据类型（报价、交易、K线、订单簿、自定义数据等）。
- 根据订阅将数据路由到适当的消费者。
- 管理从外部源到内部组件的数据流。

#### ExecutionEngine

管理订单生命周期和执行：

- 将交易命令路由到适当的适配器客户端。
- 跟踪订单和头寸状态。
- 与风险管理系统协调。
- 处理来自场所的执行报告和成交。
- 处理外部执行状态的对账。

#### RiskEngine

提供全面的风险管理：

- 交易前风险检查和验证。
- 头寸和敞口监控。
- 实时风险计算。
- 可配置的风险规则和限制。

### 环境上下文

NautilusTrader中的环境上下文定义了您正在使用的数据类型和交易场所。理解这些上下文对于有效的回测、开发和实时交易至关重要。

以下是您可以使用的可用环境：

- `Backtest`：使用模拟场所的历史数据。
- `Sandbox`：使用模拟场所的实时数据。
- `Live`：使用实时场所的实时数据（模拟交易或真实账户）。

### 通用核心

该平台被设计为在回测、沙盒和实时交易系统之间共享尽可能多的通用代码。这在`system`子包中正式化，您将在其中找到`NautilusKernel`类，提供通用核心系统"内核"。

*端口和适配器*架构风格使模块化组件能够集成到核心系统中，为用户定义或自定义组件实现提供各种钩子。

### 数据和执行流模式

理解数据和执行如何在系统中流动对于有效使用平台至关重要：

#### 数据流模式

1. **外部数据摄取**：市场数据通过场所特定的`DataClient`适配器进入，在那里进行标准化。
2. **数据处理**：`DataEngine`处理内部组件的数据处理。
3. **缓存**：处理后的数据存储在高性能`Cache`中以快速访问。
4. **事件发布**：数据事件发布到`MessageBus`。
5. **消费者交付**：订阅的组件（角色、策略）接收相关数据事件。

#### 执行流模式

1. **命令生成**：用户策略创建交易命令。
2. **命令发布**：命令通过`MessageBus`发送。
3. **风险验证**：`RiskEngine`根据配置的风险规则验证交易命令。
4. **执行路由**：`ExecutionEngine`将命令路由到适当的场所。
5. **外部提交**：`ExecutionClient`向外部交易场所提交订单。
6. **事件回流**：订单事件（成交、取消）回流通过系统。
7. **状态更新**：基于执行事件更新投资组合和头寸状态。

#### 组件状态管理

所有组件都遵循具有明确定义状态的有限状态机模式：

- **PRE_INITIALIZED**：组件已创建但尚未连接到系统。
- **READY**：组件已配置并连接，但尚未运行。
- **RUNNING**：组件正在主动处理消息和执行操作。
- **STOPPED**：组件已优雅停止，不再处理。
- **DEGRADED**：组件正在运行但由于错误而功能降低。
- **FAULTED**：组件遇到关键错误且无法继续。
- **DISPOSED**：组件已清理且资源已释放。

### 消息传递

为了促进模块化和松耦合，极其高效的`MessageBus`在组件之间传递消息（数据、命令和事件）。

从高级架构视图来看，重要的是要理解该平台被设计为在单线程上高效运行，适用于回测和实时交易。大量研究和测试得出了这个设计，因为发现线程间上下文切换的开销实际上并没有带来性能提升。

在考虑您的算法交易如何在系统边界内工作时，您可以期望每个组件以确定性同步方式消费消息（*类似于*[角色模型](https://en.wikipedia.org/wiki/Actor_model)）。

:::note
有趣的是LMAX交易所架构，它在单线程上实现了获奖性能。您可以在Martin Fowler的[这篇有趣的文章](https://martinfowler.com/articles/lmax.html)中了解他们基于*disruptor*模式的架构。
:::

## 框架组织

代码库按抽象层次分层组织，通常分组为逻辑子包的概念。您可以从左侧导航菜单导航到这些子包中每一个的文档。

### 核心/低级

- `core`：整个框架中使用的常量、函数和低级组件。
- `common`：组装框架各种组件的通用部分。
- `network`：网络客户端的低级基础组件。
- `serialization`：序列化基础组件和序列化器实现。
- `model`：定义丰富的交易域模型。

### 组件

- `accounting`：不同的账户类型和账户管理机制。
- `adapters`：平台的集成适配器，包括经纪商和交易所。
- `analysis`：与交易性能统计和分析相关的组件。
- `cache`：提供通用缓存基础设施。
- `data`：平台的数据堆栈和数据工具。
- `execution`：平台的执行堆栈。
- `indicators`：一组高效的指标和分析器。
- `persistence`：数据存储、编目和检索，主要支持回测。
- `portfolio`：投资组合管理功能。
- `risk`：风险特定组件和工具。
- `trading`：交易域特定组件和工具。

### 系统实现

- `backtest`：回测组件以及回测引擎和节点实现。
- `live`：实时引擎和客户端实现以及实时交易的节点。
- `system`：`backtest`、`sandbox`、`live`[环境上下文](#environment-contexts)之间的核心系统内核。

## 代码结构

代码库的基础是`crates`目录，包含核心Rust crate集合，包括由`cbindgen`生成的C外部函数接口（FFI）。

大部分生产代码位于`nautilus_trader`目录中，该目录包含Python/Cython子包和模块集合。

Rust核心的Python绑定通过将Rust库静态链接到编译时由Cython生成的C扩展模块来提供（有效地扩展CPython API）。

### 依赖流

```
┌─────────────────────────┐
│                         │
│                         │
│     nautilus_trader     │
│                         │
│     Python / Cython     │
│                         │
│                         │
└────────────┬────────────┘
 C API       │
             │
             │
             │
 C API       ▼
┌─────────────────────────┐
│                         │
│                         │
│      nautilus_core      │
│                         │
│          Rust           │
│                         │
│                         │
└─────────────────────────┘
```

:::note
Rust和Cython都是构建依赖项。从构建产生的二进制wheel不需要在运行时安装Rust或Cython。
:::

### 类型安全

平台的设计在最高级别优先考虑软件正确性和安全性。

`nautilus_core`中的Rust代码库始终是类型安全和内存安全的，由`rustc`编译器保证，因此是*构造正确的*（除非明确标记为`unsafe`，请参阅[开发者指南](../developer_guide/rust_CN.md)的Rust部分）。

Cython在编译时和运行时在C级别提供类型安全：

:::info
如果您向具有类型参数的Cython实现模块传递无效类型的参数，那么您将在运行时收到`TypeError`。
:::

如果函数或方法的参数没有明确类型化为接受`None`，传递`None`作为参数将在运行时导致`ValueError`。

:::warning
上述异常没有明确记录以防止文档字符串过度膨胀。
:::

### 错误和异常

已经尽一切努力准确记录可能从NautilusTrader代码引发的异常，以及将触发它们的条件。

:::warning
可能还有其他未记录的异常可能由Python标准库或第三方库依赖项引发。
:::

### 进程和线程

:::tip
为了获得最佳性能并防止与Python内存模型和相等性相关的潜在问题，强烈建议在单独的进程中运行每个交易者实例。
:::
